# PyCIPSim Delivery Roadmap

> **`SRS.md` remains the single source of truth for requirements.** Use this README as a working plan that translates those directives into implementation milestones, team workflows, and day-to-day guardrails.

## Architecture North Star

The architecture follows the capability groupings and non-functional targets captured in the SRS. Each subsection lists the first deliverable, boundaries with other components, and notable follow-ups once the baseline is in place.

| Capability | First Deliverable | Responsibilities & Boundaries | Follow-ups |
| --- | --- | --- | --- |
| **Core Simulation Engine** | Sync CIP session runner that brokers connections via `pycomm3` and emits structured transcripts. | Owns lifecycle management, deterministic retries, and abstraction of request/response envelopes. Consumes configuration generated by the Scenario Orchestrator. | Extend to asyncio tasks, add hot-swappable transports, and expose metrics required for soak testing. |
| **Device Profile Library** | Python class hierarchy describing PLC behaviors with injectable hooks for timing, jitter, and error codes. | Provides reusable building blocks for scenarios; must stay schema-compatible with scenario configuration files. | Publish a registry format, ship sample profiles aligned with the SRS sample devices, and document customization patterns. |
| **Scenario Orchestrator** | DSL/parser that loads YAML/JSON scenarios, resolves device profiles, and drives the engine accordingly. | Keeps execution state, branching logic, and report collation. Interfaces with CLI to start/stop runs. | Add real-time progress feeds, richer assertions, and authoring helpers. |
| **Automation Surface (CLI & API)** | Minimal CLI (`pycipsim run`, `pycipsim scenarios list`) with logging and exit codes suitable for CI. | Acts as the public entry point, wires environment variables, selects scenarios, and forwards report locations. | Later introduce Python API bindings, automation hooks, and optional GUI shell. |

### Planned Repository Layout

```
pycipsim/
  engine/
  orchestrator/
  devices/
  cli/
scenarios/
docs/
tests/
```

This layout keeps simulation code, orchestration logic, and user interfaces decoupled while aligning with the documentation structure mandated in the SRS.

## Milestones & Outcomes

| Milestone | Scope | Exit Criteria | Dependencies |
| --- | --- | --- | --- |
| **M0 – Project Bootstrap** | Establish repository structure, dependency management, coding standards, and CI skeleton. | Linting + unit-test workflow green; placeholder packages created; README/SRS cross-referenced. | None. |
| **M1 – Core Engine & Sample Profiles** | Implement synchronous engine, create mock PLC device profiles, and stub orchestrator integration. | Happy-path scenario executes locally with transcript output and log capture. | M0. |
| **M2 – Scenario Orchestrator Alpha** | Parse configuration files, support branching logic, produce structured reports. | CLI command runs scenarios end-to-end; reports meet SRS formatting rules. | M1. |
| **M3 – Automation & Quality Gates** | Harden CLI, expand tests, and introduce soak/performance validation harness. | CI enforces lint/type/test; soak harness reaches throughput target defined in the SRS. | M2. |
| **M4 – Extended Device Library** | Round out device behaviors, document customization, and publish examples. | Documentation & examples reviewed; coverage for device hooks hits acceptance criteria. | M3. |

## Development Environment

1. **Toolchain Requirements**
   - Python 3.10+ (per SRS §2.3).
   - `uv` or `pip` for dependency management; `pre-commit` for enforcing linting hooks.
   - Docker Desktop (or Podman) when running containerized CIP targets during integration testing.
2. **Bootstrap Commands**
   ```bash
   git clone <repo-url>
   cd PyCIPSim
   python -m venv .venv
   source .venv/bin/activate  # Windows: .venv\Scripts\activate
   python -m pip install --upgrade pip
   pip install -r requirements.txt  # generated once M0 dependency grooming finishes
   pre-commit install
   ```
3. **Local Configuration**
   - Store scenario files under `scenarios/`; align keys and field names with the schema defined in the SRS feature descriptions.
   - Export sensitive runtime data through environment variables (e.g., `PYCIPSIM_TARGET_IP`, `PYCIPSIM_SESSION_TIMEOUT`).
   - Direct logs to `logs/` by default. Override with `--log-dir` once the CLI milestone lands.
   - Keep device fixtures in `tests/fixtures/devices/` so they can be re-used across unit and integration suites.

## Testing & Quality Strategy

Automated confidence grows with each milestone. The SRS quality metrics (performance, availability, traceability) are explicitly mapped below.

1. **Static Analysis & Style**
   - Run `pre-commit run --all-files` locally; CI mirrors the same hooks (formatting, linting, type checks via `ruff`, `black`, `mypy`).
   - Ensure docstrings reference the relevant SRS requirement identifiers for traceability.
2. **Unit Tests**
   - Use `pytest` with `pytest-asyncio` reserved for future async work.
   - Mock `pycomm3` clients to validate state transitions, error handling, and transcript generation without hardware dependencies.
3. **Integration Tests**
   - Spin up simulated PLC endpoints (e.g., containerized CIP echo service) and verify end-to-end orchestration.
   - Capture transcripts as JSON Lines and compare to SRS-defined schemas using `pydantic` models.
4. **Performance & Reliability**
   - Leverage a stress harness (`tests/perf/`) to drive ≥100 CIP messages/second and document throughput in CI artifacts.
   - Execute soak tests (≥24h) before releases; log stability metrics and compare against SRS availability targets.
5. **Reporting & Traceability**
   - Publish HTML coverage, JSON requirement trace matrices, and scenario reports as build artifacts.
   - Update the roadmap when SRS revisions add or remove requirements; capture deltas in `docs/changelog.md`.

## Operational Next Steps

- Finalize dependency lists and scaffolding scripts as part of Milestone M0.
- Create architectural decision records under `docs/adr/` beginning with the transport abstraction choice.
- Implement the planned package layout with placeholder modules and docstrings that reference SRS requirement IDs.
- Stand up CI (GitHub Actions or similar) executing lint, type, unit, and integration suites.
- Revisit this roadmap after each milestone review to ensure parity with [`SRS.md`](./SRS.md).

For any clarifications or requirement updates, defer to [`SRS.md`](./SRS.md) and annotate implementation work with its requirement identifiers.
