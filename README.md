# PyCIPSim Delivery Roadmap

> **`SRS.md` remains the single source of truth for requirements.** Use this README as a working plan that translates those directives into implementation milestones, team workflows, and day-to-day guardrails.

## Architecture North Star

The architecture follows the capability groupings and non-functional targets captured in the SRS. Each subsection lists the first deliverable, boundaries with other components, and notable follow-ups once the baseline is in place.

| Capability | First Deliverable | Responsibilities & Boundaries | Follow-ups |
| --- | --- | --- | --- |
| **Core Simulation Engine** | Sync CIP session runner that brokers connections via `pycomm3` and emits structured transcripts. | Owns lifecycle management, deterministic retries, and abstraction of request/response envelopes. Consumes configuration generated by the Scenario Orchestrator. | Extend to asyncio tasks, add hot-swappable transports, and expose metrics required for soak testing. |
| **Device Profile Library** | Python class hierarchy describing PLC behaviors with injectable hooks for timing, jitter, and error codes. | Provides reusable building blocks for scenarios; must stay schema-compatible with scenario configuration files. | Publish a registry format, ship sample profiles aligned with the SRS sample devices, and document customization patterns. |
| **Scenario Orchestrator** | DSL/parser that loads YAML/JSON scenarios, resolves device profiles, and drives the engine accordingly. | Keeps execution state, branching logic, and report collation. Interfaces with CLI to start/stop runs. | Add real-time progress feeds, richer assertions, and authoring helpers. |
| **Automation Surface (CLI & API)** | Minimal CLI (`pycipsim run`, `pycipsim scenarios list`) with logging and exit codes suitable for CI. | Acts as the public entry point, wires environment variables, selects scenarios, and forwards report locations. | Later introduce Python API bindings, automation hooks, and optional GUI shell. |

### Planned Repository Layout

```
pycipsim/
  engine/
  orchestrator/
  devices/
  cli/
scenarios/
docs/
tests/
```

This layout keeps simulation code, orchestration logic, and user interfaces decoupled while aligning with the documentation structure mandated in the SRS.

## Milestones & Outcomes

| Milestone | Scope | Exit Criteria | Dependencies |
| --- | --- | --- | --- |
| **M0 – Project Bootstrap** | Establish repository structure, dependency management, coding standards, and CI skeleton. | Linting + unit-test workflow green; placeholder packages created; README/SRS cross-referenced. | None. |
| **M1 – Core Engine & Sample Profiles** | Implement synchronous engine, create mock PLC device profiles, and stub orchestrator integration. | Happy-path scenario executes locally with transcript output and log capture. | M0. |
| **M2 – Scenario Orchestrator Alpha** | Parse configuration files, support branching logic, produce structured reports. | CLI command runs scenarios end-to-end; reports meet SRS formatting rules. | M1. |
| **M3 – Automation & Quality Gates** | Harden CLI, expand tests, and introduce soak/performance validation harness. | CI enforces lint/type/test; soak harness reaches throughput target defined in the SRS. | M2. |
| **M4 – Extended Device Library** | Round out device behaviors, document customization, and publish examples. | Documentation & examples reviewed; coverage for device hooks hits acceptance criteria. | M3. |

## Development Environment

1. **Toolchain Requirements**
   - Python 3.10+ (per SRS §2.3).
   - `uv` or `pip` for dependency management; `pre-commit` for enforcing linting hooks.
   - Docker Desktop (or Podman) when running containerized CIP targets during integration testing.
2. **Bootstrap Commands**
   ```bash
   git clone <repo-url>
   cd PyCIPSim
   python -m venv .venv
   source .venv/bin/activate  # Windows: .venv\Scripts\activate
   python -m pip install --upgrade pip
   pip install -r requirements.txt  # generated once M0 dependency grooming finishes
   pre-commit install
   ```
3. **Local Configuration**
   - Store scenario files under `scenarios/`; align keys and field names with the schema defined in the SRS feature descriptions.
   - Export sensitive runtime data through environment variables (e.g., `PYCIPSIM_TARGET_IP`, `PYCIPSIM_SESSION_TIMEOUT`).
   - Direct logs to `logs/` by default. Override with `--log-dir` once the CLI milestone lands.
   - Keep device fixtures in `tests/fixtures/devices/` so they can be re-used across unit and integration suites.

## Testing & Quality Strategy

Automated confidence grows with each milestone. The SRS quality metrics (performance, availability, traceability) are explicitly mapped below.

1. **Static Analysis & Style**
   - Run `pre-commit run --all-files` locally; CI mirrors the same hooks (formatting, linting, type checks via `ruff`, `black`, `mypy`).
   - Ensure docstrings reference the relevant SRS requirement identifiers for traceability.
2. **Unit Tests**
   - Use `pytest` with `pytest-asyncio` reserved for future async work.
   - Mock `pycomm3` clients to validate state transitions, error handling, and transcript generation without hardware dependencies.
3. **Integration Tests**
   - Spin up simulated PLC endpoints (e.g., containerized CIP echo service) and verify end-to-end orchestration.
   - Capture transcripts as JSON Lines and compare to SRS-defined schemas using `pydantic` models.
4. **Performance & Reliability**
   - Leverage a stress harness (`tests/perf/`) to drive ≥100 CIP messages/second and document throughput in CI artifacts.
   - Execute soak tests (≥24h) before releases; log stability metrics and compare against SRS availability targets.
5. **Reporting & Traceability**
   - Publish HTML coverage, JSON requirement trace matrices, and scenario reports as build artifacts.
   - Update the roadmap when SRS revisions add or remove requirements; capture deltas in `docs/changelog.md`.

## Operational Next Steps

- Finalize dependency lists and scaffolding scripts as part of Milestone M0.
- Create architectural decision records under `docs/adr/` beginning with the transport abstraction choice.
- Implement the planned package layout with placeholder modules and docstrings that reference SRS requirement IDs.
- Stand up CI (GitHub Actions or similar) executing lint, type, unit, and integration suites.
- Revisit this roadmap after each milestone review to ensure parity with [`SRS.md`](./SRS.md).

For any clarifications or requirement updates, defer to [`SRS.md`](./SRS.md) and annotate implementation work with its requirement identifiers.
# PyCIPSim

> **Authoritative requirements live in [`SRS.md`](./SRS.md).** This README explains how the current codebase implements those
> directives, how to get started locally, and what work remains.

## Overview

PyCIPSim is a Python toolkit for simulating Common Industrial Protocol (CIP) traffic so that PLC integrations can be exercised
without dedicated hardware. The implementation mirrors the major capabilities defined in the SRS:

- **Session Management (`pycipsim.session`)** — wraps the lifecycle of CIP connections, provides retry semantics, and exposes
  a unified interface for both simulated devices and live PLCs (via `pycomm3`).
- **Device Profiles (`pycipsim.device`)** — captures reusable PLC behaviours, fault injections, and request/response data
  structures.
- **Scenario Execution (`pycipsim.engine`)** — orchestrates scripted message exchanges, validates expectations, and generates
  machine-readable reports.
- **Automation Surface (`pycipsim.cli`)** — Click-powered CLI that runs scenarios, lists bundled profiles, and scaffolds new
  scenario definitions while emitting rich console output.

All modules log through `pycipsim.logging_config` to honour the observability requirements in the SRS.

## Repository Layout

```
pyproject.toml
src/
  pycipsim/
    __init__.py
    cli.py
    device.py
    engine.py
    logging_config.py
    session.py
tests/
  test_scenario.py
```

The `src/` layout keeps runtime packages separate from tests and documentation, simplifying packaging and tooling integration.

## Getting Started

### Prerequisites

- Python 3.10 or newer (per SRS §2.4).
- `pip` or `uv` for dependency installation.
- Optional: `pycomm3` when connecting to real PLC hardware.

### Installation

```bash
python -m venv .venv
source .venv/bin/activate  # Windows: .venv\Scripts\activate
python -m pip install --upgrade pip
pip install -e .[dev]
# Optional hardware support
pip install pycomm3
```

### Running the CLI

1. Generate a scenario template:
   ```bash
   pycipsim scaffold scenarios/echo.json
   ```
2. Execute the scenario against the default simulated Echo profile:
   ```bash
   pycipsim run --scenario scenarios/echo.json --report reports/echo.json
   ```
3. Inspect the bundled device profiles:
   ```bash
   pycipsim list-profiles
   ```

When `pycomm3` is available you can point the same command at live hardware with `--ip`, `--port`, and `--slot` overrides. The
CLI emits structured JSON reports suitable for CI consumption as required in SRS §3.5.

### Authoring Scenarios

Scenarios are JSON arrays with each element describing a single request/expectation pair:

```json
[
  {
    "request": {
      "service_code": "ECHO",
      "tag_path": "TagA",
      "payload": "Hello CIP",
      "metadata": {"comment": "Sample"}
    },
    "expected_status": "SUCCESS",
    "description": "Validate echo behaviour"
  }
]
```

The CLI loader mirrors this structure and converts payload strings to bytes internally. Scenario execution halts on the first
failure by default, but `--no-halt` enables full-run auditing.

### Device Profiles

`pycipsim.device` includes two sample profiles to speed up local testing:

- **EchoDevice** — returns the request payload unchanged (`ECHO` service), supporting connectivity checks.
- **CounterDevice** — increments a per-tag counter (`READ` service), useful for exercising stateful scenarios.

Fault injection helpers such as `drop_request_fault` and `delay_response_fault` can be composed into custom profiles to satisfy
robustness testing requirements in SRS §3.3.

## Testing & Quality

Automated testing currently covers scenario execution with simulated devices. Run the suite with:

```bash
pytest
```

Future milestones will layer in additional checks to match the SRS quality targets:

- Static analysis (`mypy`, `ruff`) and formatting hooks via `pre-commit`.
- Integration tests targeting containerised PLC simulators once transport adapters are extended.
- Performance harnesses to validate the ≥100 message-per-second throughput in SRS §5.1.

## Roadmap Highlights

Short-term work should focus on:

1. **Transport Extensibility** — introduce additional adapters (e.g., asynchronous, UDP) while maintaining compatibility with
   the `Transport` protocol in `session.py`.
2. **Scenario DSL Enhancements** — expand beyond JSON arrays to support branching, timing constraints, and assertions mapped to
   explicit SRS requirement IDs.
3. **Reporting Improvements** — emit structured metrics (counts, latency histograms) to satisfy monitoring goals in SRS §3.4.
4. **Documentation & Traceability** — link code artifacts back to SRS sections and maintain an ADR log under `docs/`.

Refer back to [`SRS.md`](./SRS.md) after each milestone review to ensure the README and implementation remain aligned.
